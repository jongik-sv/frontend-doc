훌륭한 주제입니다! 이번 내용은 리액트를 사용하면서 반드시 이해하고 있어야 할 **상태(state)의 위치 기반 추적 원리**, 그리고 동적 리스트에서 **key의 역할과 중요성**에 대한 설명입니다. 아래는 이 내용을 블로그 포스트 형식으로 정리한 글입니다.

---

# 🧠 React 상태는 어디에 저장될까? — 위치 기반 추적과 key의 중요성

리액트를 사용할 때 우리는 흔히 `useState`로 상태를 선언하고 관리합니다.  
하지만 이 상태가 **어떻게 컴포넌트에 귀속되고**, **왜 어떤 상황에서는 의도와 다르게 동작하는지**,  
그리고 그 해결책이 **key 속성**에 있다는 사실은 놓치기 쉽습니다.

이번 글에서는 상태의 위치 기반 추적 개념과 함께,  
동적 리스트에서 발생할 수 있는 **state 버그**를 **실전 예제**로 설명드리겠습니다.

---

## 📍 상태는 컴포넌트의 “위치”에 귀속된다

### ✔️ 중요한 개념

- `useState`로 만든 상태는 **컴포넌트 함수의 실행 위치**에 따라 추적됩니다.
    
- 동일한 컴포넌트 함수라 하더라도, **화면에서의 위치가 다르면** 각각 독립된 상태를 갖습니다.
    
- 예를 들어, `Counter` 컴포넌트를 두 번 렌더링하면 **서로 다른 상태 인스턴스**가 생성됩니다.
    

```jsx
<App>
  <Counter initialCount={0} />
  <Counter initialCount={100} />
</App>
```

위처럼 동일한 `Counter` 컴포넌트라도 서로 독립된 상태를 갖습니다.  
✔️ 이유: **컴포넌트의 타입(type)과 위치(position)**가 다르기 때문입니다.

---

## 🧪 상태가 이상하게 “넘어가는” 현상?

예제를 통해 상태가 **의도와 다르게 다른 컴포넌트로 이동하는 현상**을 살펴보겠습니다.

### 💥 문제 상황

- `CounterHistory`라는 컴포넌트가 변화 이력을 렌더링합니다.
    
- 각 항목은 `HistoryItem`이라는 컴포넌트로 렌더링되며, 클릭하면 강조(highlight)됩니다.
    
- 그러나 항목이 추가될 때마다 **이전 항목의 상태가 새 항목으로 옮겨짐** 😨
    

```jsx
history.map((item, index) => (
  <HistoryItem key={index} value={item.value} />
));
```

### ❌ 상태가 건너뛴 이유는?

- `useState`는 위치 기반으로 상태를 추적합니다.
    
- 위에서 `index`를 key로 사용했기 때문에, 항목의 순서가 바뀌면 **같은 위치에 다른 컴포넌트가 들어오게 됩니다.**
    
- 결과적으로 이전 컴포넌트의 상태가 새 컴포넌트로 “이동”하게 됩니다.
    

---

## ✅ 해결 방법: **고유한 ID 기반의 key 사용**

리액트에서 key는 단지 반복을 위한 식별자가 아닙니다.  
**key는 상태를 특정 컴포넌트 인스턴스에 정확하게 매핑하는 기준**입니다.

### 🔁 잘못된 예

```jsx
key={index} // ❌ 항목의 위치가 바뀌면 문제 발생
```

### ✅ 올바른 예

```jsx
key={item.id} // ✅ 항목 고유 ID를 기반으로 상태 고정
```

이를 위해 상태 값을 객체화하고, 고유 ID를 포함시킵니다:

```jsx
setCounter(prev => [
  { id: Math.random(), value: prev + 1 },
  ...prev
]);
```

---

## 🧠 왜 index를 key로 쓰면 안 되는가?

|상황|index 사용의 문제점|
|---|---|
|항목이 추가/삭제될 때|기존 항목의 위치가 바뀌므로 상태가 꼬임|
|상태 있는 자식 컴포넌트|상태가 다른 컴포넌트로 넘어감|
|상태 바인딩이 중요할 때|의도하지 않은 상태 재사용 발생|

index를 key로 사용할 수 있는 **예외적인 경우**도 있습니다:

- 리스트가 절대 변하지 않음
    
- 단순한 텍스트 목록이고 상태 없음
    

하지만 **상태가 있는 컴포넌트**에서 index는 절대 사용하지 마세요!

---

## 🎯 상태는 "컴포넌트 타입 + 위치 + key"로 추적된다

React는 내부적으로 컴포넌트의 상태를 아래와 같은 기준으로 추적합니다:

```
상태 저장 기준 = 컴포넌트 타입 + key + 위치
```

- 타입: 어떤 컴포넌트인지 (예: `HistoryItem`)
    
- 위치: 리스트에서 렌더링된 순서 (index 아님!)
    
- key: 명확한 ID가 없을 경우 index로 대체되며, 문제 발생 가능성 높음
    

---

## ✅ 정리

|개념|설명|
|---|---|
|`useState`는 위치 기반|컴포넌트가 렌더링된 위치에 따라 상태를 기억함|
|컴포넌트 재사용 시|각 인스턴스는 별도 상태를 가짐|
|리스트에서 key 역할|상태가 올바른 컴포넌트에 매핑되도록 보장|
|key로 index를 쓰면 안 되는 이유|순서 바뀔 경우 상태가 다른 항목으로 넘어감|

---

## 💡 마무리

상태는 리액트의 핵심이며, 그 동작 원리를 **"컴포넌트 위치 + key 기반 추적"**이라는 관점으로 이해하면  
복잡한 렌더링 오류나 예기치 않은 상태 변경 문제를 훨씬 쉽게 디버깅할 수 있습니다.

특히 리스트를 렌더링할 땐 항상 **고유한 key**를 사용하세요.  
이것 하나로 리액트 앱의 버그 대부분을 예방할 수 있습니다.

---

다음 글에서는 리스트에서의 key와 함께 자주 사용하는 `useReducer`, 그리고 상태를 구조화하여 관리하는 전략까지 소개해드릴게요!  
필요하시면 HistoryItem 예제를 실제 코드로 정리해드릴 수도 있어요. 말씀만 주세요 😄