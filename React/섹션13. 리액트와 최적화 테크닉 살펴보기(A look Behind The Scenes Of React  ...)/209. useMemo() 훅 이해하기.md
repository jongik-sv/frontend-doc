물론입니다! 이번 내용은 **리액트의 `useMemo` 훅을 활용한 계산 최적화**에 관한 강의로, 단순히 컴포넌트 렌더링을 막는 것이 아니라, **함수 실행 자체의 불필요한 반복을 방지하는 고급 전략**에 해당합니다. 아래는 블로그용으로 정리한 포스트입니다.

---

# 🧠 계산 최적화를 위한 `useMemo` 사용법 — 단순 렌더링 방지 그 이상

리액트를 사용하면서 불필요한 **렌더링(rendering)**만큼이나 간과하기 쉬운 것이 있습니다.  
바로 **컴포넌트 안에서 실행되는 무거운 함수**들이, 값이 바뀌지 않아도 매번 실행된다는 점입니다.

이번 글에서는 `useMemo` 훅을 이용해 **복잡한 계산 결과를 메모이제이션(memoization)**하여  
앱의 성능을 **눈에 띄게 개선**할 수 있는 방법을 알아봅니다.

---

## 💥 문제 상황: 함수는 바뀐 게 없는데 매번 다시 실행된다?

```jsx
function Counter({ initialCount }) {
  const isPrime = checkIsPrime(initialCount); // 매번 실행됨
  ...
}
```

위 코드처럼 `Counter` 컴포넌트가 재실행되면,  
**상태와 상관없이 `checkIsPrime` 함수도 무조건 다시 호출**됩니다.

그리고 이 함수가 단순한 로직이라면 문제가 되지 않지만,  
**큰 수를 판별하거나 무거운 계산 로직**이라면 실행 자체가 성능에 부담이 됩니다.

---

## ⚡ 해결책: `useMemo`로 계산 결과를 기억시키기

```jsx
const isPrime = useMemo(() => checkIsPrime(initialCount), [initialCount]);
```

- `checkIsPrime(initialCount)`의 결과는 **initialCount가 바뀔 때만 재계산**됩니다.
    
- 그 외 상태(`count` 등)가 바뀔 때는 이전 결과를 **메모리에서 그대로 재사용**합니다.
    

---

## ✅ `useMemo` 핵심 사용법 요약

|구성 요소|설명|
|---|---|
|첫 번째 인자|**익명 함수**: 계산 함수 실행을 래핑|
|두 번째 인자|**의존성 배열**: 언제 다시 계산할지를 결정|

```jsx
const result = useMemo(() => expensiveFunction(x, y), [x, y]);
```

이 구조를 통해 **렌더링이 재실행되어도 계산은 불필요하게 반복되지 않습니다.**

---

## 🧪 실습 예시: 소수 판별 함수 `isPrime()`

```jsx
function isPrime(n) {
  for (let i = 2; i <= Math.sqrt(n); i++) {
    if (n % i === 0) return false;
  }
  return n > 1;
}
```

```jsx
function Counter({ initialCount }) {
  const primeCheck = useMemo(() => isPrime(initialCount), [initialCount]);

  return <p>{initialCount}는 {primeCheck ? '소수입니다' : '소수가 아닙니다'}</p>;
}
```

✔️ 이제 카운터 값을 증가해도 `initialCount`가 바뀌지 않는 이상,  
`isPrime` 함수는 다시 실행되지 않습니다.

---

## 🔍 `useMemo` vs `memo` 차이점은?

| 항목     | `useMemo`        | `React.memo`        |
| ------ | ---------------- | ------------------- |
| 목적     | **값(계산 결과)를 캐싱** | **컴포넌트 자체의 렌더링 방지** |
| 적용 대상  | 일반 함수, 무거운 계산    | 전체 컴포넌트 함수          |
| 재실행 조건 | 의존성 배열이 바뀔 때만    | props가 변경될 때만       |

> ⚠️ 혼동하지 마세요!  
> `useMemo`는 값 캐싱, `memo`는 컴포넌트 캐싱입니다.

---

## 🚨 주의: 무분별한 `useMemo` 사용은 오히려 비효율

- 모든 함수에 `useMemo`를 쓰면 메모리와 비교 비용이 증가
    
- 단순한 연산이나 매번 새로 계산해야 하는 값에는 **오히려 역효과**
    
- 적절한 사용 시점: **고비용 연산 + 동일 입력에 동일 결과**
    

---

## ✅ 정리

|상황|`useMemo` 사용 여부|
|---|---|
|계산 결과가 동일한 경우가 많고 무겁다|✅ 사용 권장|
|계산 자체가 빠르고 단순하다|❌ 불필요|
|값이 자주 바뀌며 매번 계산이 필요하다|❌ 사용 지양|
|렌더링 최적화보다 코드를 명확히 하고 싶을 때|⚠️ 신중 사용|

---

## 💬 마무리

`useMemo`는 성능을 향상시키는 **날카로운 도구**입니다. 하지만 칼을 아무 데나 휘두르면 다칠 수도 있듯,  
**무조건적인 사용은 성능에 오히려 해로울 수 있습니다.**

핵심은 **값이 자주 바뀌지 않는 고비용 계산**이 있는 경우에만 사용하는 것!  
이 기준만 잘 지킨다면, 여러분의 앱은 더 빠르고 효율적으로 작동할 것입니다.

---

다음 포스트에서는 `useMemo`와 함께 자주 사용되는 `useCallback`, `memo` 조합을 통해  
**실제 컴포넌트 성능을 분석하고 최적화하는 실습 예시**도 함께 소개할게요! 👨‍💻

필요하시면 isPrime 예제 전체 코드도 정리해드릴게요. 원하시나요?