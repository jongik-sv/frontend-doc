훌륭한 주제입니다! 지금까지는 리액트에서 **컴포넌트 함수 실행 및 렌더링 최적화**에 집중했다면, 이번에는 **JSX가 실제 DOM으로 어떻게 변환되고 업데이트되는지**, 즉 **React의 렌더링 메커니즘과 Virtual DOM 개념**을 중심으로 다루고 있습니다. 아래는 블로그 포스팅 형식으로 정리한 글입니다.

---

# 🔍 JSX는 어떻게 실제 DOM이 되는가? — 리액트 렌더링 메커니즘 완전 정복

리액트는 컴포넌트 중심으로 작동하며, JSX를 반환하는 함수처럼 보입니다.  
하지만 그 안에서는 **생각보다 훨씬 정교한 렌더링 로직**이 동작하고 있습니다.

이번 글에서는 "JSX가 어떻게 실제 HTML로 변환되는가?", 그리고 "컴포넌트 함수가 실행될 때 실제로 어떤 일이 벌어지는가?"에 대해 알아보겠습니다.

---

## 🔧 렌더링의 시작: 컴포넌트 함수 실행 → JSX 반환

먼저, 리액트의 렌더링 과정은 다음과 같이 시작됩니다:

1. **컴포넌트 함수 실행**
    
2. **JSX 코드 반환**
    
3. **리액트가 이 JSX를 기반으로 컴포넌트 트리 생성**
    
4. **최종적으로는 네이티브 HTML 요소로 변환**
    

예를 들어, `Counter` 컴포넌트가 다음과 같다고 해봅시다:

```jsx
function Counter({ initialCount }) {
  return (
    <section>
      <p>
        현재 값: <span>{initialCount}</span>
      </p>
      <button>증가</button>
    </section>
  );
}
```

이 JSX 코드는 결국 React에 의해 **자바스크립트 객체 형태로 변환되고**, 내부적으로 **가상 DOM(Virtual DOM)**을 구성하게 됩니다.

---

## 🧠 리액트의 핵심: Virtual DOM

**가상 DOM(Virtual DOM)**은 리액트가 실제 DOM을 직접 조작하지 않고,  
**메모리 상에 존재하는 DOM의 복제본**을 기반으로 렌더링 성능을 최적화하는 핵심 기술입니다.

### 🔁 렌더링 사이클 요약

1. **초기 로딩 시**
    
    - React는 컴포넌트 트리를 실행하고 JSX → JS 객체로 변환
        
    - 이를 바탕으로 **Virtual DOM Snapshot** 생성
        
    - Snapshot을 실제 DOM에 "최초로" 반영
        
2. **상태나 props가 바뀔 때**
    
    - 컴포넌트가 재실행되고 새로운 JSX → 새로운 Virtual DOM
        
    - 이전 Snapshot과 **비교(Diffing)** 수행
        
    - 바뀐 부분만 **실제 DOM에 최소한으로 반영(Patching)**
        

---

## 🔍 실제로 어떤 부분이 갱신되는가?

예시: Counter 값 증가 시

```jsx
<span>{count}</span>
```

이 때, 크롬 개발자 도구로 보면 **오직 이 `<span>` 요소만 깜빡**입니다.  
즉, **오직 해당 DOM 노드만 갱신**되었고, `<p>`, `<button>` 등의 나머지 요소는 전혀 영향을 받지 않습니다.

✔️ 이것이 바로 React의 **최소 단위 DOM 업데이트 방식**입니다.

---

## 🚨 중요한 오해: JSX가 바뀐다고 무조건 DOM이 바뀌는 게 아님

컴포넌트 함수가 재실행되어 새로운 JSX를 반환한다고 해도,  
**실제 DOM이 무조건 다시 그려지는 것은 아닙니다.**

리액트는 JSX가 변한 것처럼 보여도 내부적으로는 다음 절차를 따릅니다:

1. JSX → Virtual DOM 객체로 변환
    
2. 이전 Virtual DOM과 비교
    
3. **바뀐 부분만 DOM 업데이트**
    

> ✅ 이 과정 덕분에 React는 "빠르다"고 평가받습니다.

---

## 📦 인덱스 HTML과 리액트 앱 구조

```html
<!-- index.html -->
<body>
  <div id="root"></div>
  <script src="bundle.js"></script>
</body>
```

- 초기 페이지는 `<div id="root">`만 존재
    
- 리액트 앱은 **이 루트 노드에 전체 컴포넌트 트리를 삽입**함
    
- 이후 모든 렌더링은 **이 root 내부에서만** 일어납니다
    

---

## 🔬 DOM 갱신 과정 예시

```plaintext
[Counter 컴포넌트 재실행됨]
→ 새로운 JSX 생성
→ Virtual DOM 스냅샷 생성
→ 이전 스냅샷과 비교
→ 바뀐 부분 감지 (e.g. <span> 텍스트)
→ 해당 DOM 요소만 업데이트
```

이 과정을 **React DevTools 또는 Chrome Elements 패널**에서 확인해보면,  
실제 DOM이 깜빡이는 요소만 부분적으로 바뀌는 것을 시각적으로 관찰할 수 있습니다.

---

## ✅ 핵심 요약

|항목|설명|
|---|---|
|컴포넌트 실행 시|JSX 반환 → Virtual DOM 생성|
|Virtual DOM|메모리 내 DOM 구조|
|DOM 업데이트|이전 Virtual DOM과 비교 후, 필요한 부분만 변경|
|성능 최적화 핵심|"변한 것만 실제로 바꾼다"는 전략|

---

## 💡 결론

리액트는 단순히 JSX → HTML 변환을 반복하지 않습니다.  
**Virtual DOM을 통해 최소한의 DOM 조작만 수행**함으로써  
브라우저 렌더링 성능을 극대화하고, **불필요한 DOM 조작을 방지**합니다.

이 원리를 이해하면 `memo`, `useMemo`, `useCallback` 같은 훅들이  
**왜 필요한지**, 그리고 어떤 경우에 사용해야 하는지도 더욱 명확해집니다.

---

다음 글에서는 이 렌더링 흐름을 기반으로,  
**컴포넌트의 생애 주기와 렌더링 흐름 시각화 도구(Profiler)** 사용법도 함께 소개해드릴게요!

혹시 위 내용을 기반으로 **렌더링 흐름 다이어그램**이나 시각자료도 함께 보고 싶으신가요? 필요하시면 추가로 그려드릴게요 😊